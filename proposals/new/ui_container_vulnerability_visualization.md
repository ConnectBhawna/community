# Proposal: Developing a UI for Container Vulnerability Visualization

This is a feature proposal for [issue 10496](https://github.com/goharbor/harbor/issues/10496)

Author: Bhawna Chauhan [@ConnectBhawna](https://github.com/ConnectBhawna/)


## Abstract
It can be frustrating and time-consuming to manually check each individual container tag for vulnerabilities in our Harbor registry.This proposal is to add a UI that shows the status of container scans based on a user's permissions to view specific projects. 

## Background

As discussed in [issue 10496](https://github.com/goharbor/harbor/issues/10496), the support for a UI that shows the status of container is been desired by the Harbor user community for a long time now. Users have to manually check each individual container tag for vulnerabilities in our Harbor registry which is really time consuming.

## Goals

* Identify user requirements and determine which information to include in the UI, such as container scan status, number of vulnerabilities per container, and vulnerability severity.

* Selecting a suitable data visualization tool, such as Grafana, Kibana, or Tableau, that aligns with user requirements and integrates with the container scanning tool in use.

* Integrate the container scanning tool and the visualization tool using API endpoints or plugins.

* Establish access control policies for the UI based on user roles and permissions to restrict unauthorized data access.

* Test the UI with real data, gather feedback from users, and iterate the design to ensure desired insights are provided.

* Deploy the UI to production, ensure it is maintained and updated, and monitor the tool for issues, making necessary updates.


## Implementation

1. To implement a UI for container vulnerability visualization, my first step is to understand the user's needs and requirements. This involves identifying the information that should be included in the UI, such as container scan status, number of vulnerabilities per container, and vulnerability severity. The user requirements should be clearly defined to ensure that the final product meets their needs.

2. Selecting a suitable data visualization tool, such as Grafana, Kibana, or Tableau, that aligns with user requirements and integrates with the container scanning tool in use.
### Psuedo-code Snippet
This is the code snippet of Integrating Kibana with a container 

```go
package main
//Here we uses the go-elasticsearch library to connect to Elasticsearch and make an HTTP request to Kibana to retrieve a dashboard.
import (
    "net/http"
    "github.com/elastic/go-elasticsearch/v8"
    "github.com/elastic/go-elasticsearch/v8/esapi"
)

func main() {
    // Connect to Elasticsearch
    es, err := elasticsearch.NewDefaultClient()
    if err != nil {
        // Handle error
    }

    // Set up HTTP request to Kibana
    req, err := http.NewRequest(http.MethodGet, "http://localhost:5601/api/kibana/dashboards/1", nil)
    if err != nil {
        // Handle error
    }

    // Execute request
    res, err := es.PerformRequest(context.Background(), req)
    if err != nil {
        // FOr Handle error
    }
    
    // Handle response
    defer res.Body.Close()
    if res.IsError() {
        // Here we Handle error
    }
    // than we do something with the response data
}

```


3. Here is code sample that demonstrates how to integrate Kibana with a container scanning tool using API endpoints in Golang:


```go
package main

import (
    "encoding/json"
    "net/http"

    "github.com/elastic/go-elasticsearch/v8"
)

func main() {
    // Connect to Kibana and the container scanning tool
    kibanaClient, err := elasticsearch.NewDefaultClient()
    if err != nil {
        // Handle error
    }
    scanningClient := NewContainerScanningClient()

    // Define API endpoints
    http.HandleFunc("/vulnerabilities", func(w http.ResponseWriter, r *http.Request) {
        // Retrieve data from the container scanning tool
        data, err := scanningClient.GetVulnerabilityData()
        if err != nil {
            // Handle error
        }

        // Format data for Kibana
        formattedData := FormatDataForKibana(data)

        // Send data back to Kibana
        res, err := kibanaClient.Index("vulnerability-index", strings.NewReader(formattedData))
        if err != nil {
            // Handle error
        }

        // Send response back to client
        json.NewEncoder(w).Encode(res)
    })

    // Start server
    http.ListenAndServe(":8080", nil)
}

func FormatDataForKibana(data []VulnerabilityData) string {
    // Format data as JSON
    jsonBytes, err := json.Marshal(data)
    if err != nil {
        // Handle error
    }

    return string(jsonBytes)
}

```

The above snippet can also be modified as per the mentor want.


4. In order to establish access control policies for the UI based on user roles and permissions, we can use the built-in role-based access control (RBAC) functionality of Harbor.

### Psuedo-code Snippet

Here is an example code to define access control policies in Harbor

```go
import (
  "github.com/goharbor/harbor/src/server/auth"
  "github.com/goharbor/harbor/src/server/dao"
  "github.com/goharbor/harbor/src/server/models"
)

// Define access control policies for the UI based on user roles and permissions
func defineAccessControlPolicies() {
  // Define the roles and their corresponding permissions
  roles := []auth.Role{
    {
      Name: "Admin",
      Permissions: []auth.Permission{
        dao.PermissionRead,
        dao.PermissionWrite,
        dao.PermissionDelete,
      },
    },
    {
      Name: "Developer",
      Permissions: []auth.Permission{
        dao.PermissionRead,
        dao.PermissionWrite,
      },
    },
    {
      Name: "Viewer",
      Permissions: []auth.Permission{
        dao.PermissionRead,
      },
    },
  }

  // Loop through the roles and create them if they don't exist
  for _, role := range roles {
    existingRole, err := auth.GetRoleByName(role.Name)
    if err != nil {
      // Create the role if it doesn't exist
      auth.CreateRole(&role)
    } else {
      // Update the role if it already exists
      role.ID = existingRole.ID
      auth.UpdateRole(&role)
    }
  }

  // Define the user roles
  userRoles := []models.UserRole{
    {
      UserID: 1, // Replace with the actual user ID
      RoleID: 1, // Replace with the actual role ID for the "Admin" role
    },
    {
      UserID: 2, // Replace with the actual user ID
      RoleID: 2, // Replace with the actual role ID for the "Developer" role
    },
    {
      UserID: 3, // Replace with the actual user ID
      RoleID: 3, // Replace with the actual role ID for the "Viewer" role
    },
  }

  // Loop through the user roles and create them if they don't exist
  for _, userRole := range userRoles {
    existingUserRole, err := models.GetUserRole(userRole.UserID, userRole.RoleID)
    if err != nil {
      // Create the user role if it doesn't exist
      models.CreateUserRole(&userRole)
    } else {
      // Update the user role if it already exists
      userRole.ID = existingUserRole.ID
      models.UpdateUserRole(&userRole)
    }
  }
}


```
This code defines three roles ("Admin", "Developer", and "Viewer") and their corresponding permissions. It also defines user roles for three sample users, assigning them the appropriate roles.We can customize this code to define the roles and permissions that are appropriate for your use case.

Footer